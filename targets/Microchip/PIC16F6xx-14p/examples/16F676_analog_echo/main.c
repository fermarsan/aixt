// This C code was automatically generated by Aixt Compiler
//     https://github.com/fermarsan/aixt
// Device = PIC16F676
// Board = ---
// Backend = c

#include <xc.h>
#include <stdbool.h>
#include <stdint.h>
typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
// typedef NOT SUPPORTED i64;
typedef int8_t isize;
typedef int32_t int_literal;
typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
// typedef NOT SUPPORTED u64;
typedef uint8_t usize;
typedef float f32;
// typedef NOT SUPPORTED f64;
typedef float float_literal;
typedef char rune;

#define _const_main__cpu_freq_mhz	_const_main__cpu_freq/1000000
#define _const_main__cpu_freq  20000000

#define _XTAL_FREQ 20000000

#pragma config MCLRE = OFF
#pragma config CP = OFF
#pragma config CPD = OFF
#pragma config BOREN = ON
#pragma config FOSC = HS
#pragma config WDTE = OFF

#define ADCON0_CHS  ADCON0bits.CHS

u16  adc__read(u8 channel);
u8  adc__read_byte(u8 channel);

#define _const_port__a 0
#define _const_port__c 2
#define _const_port__all_inputs 0b11111111
#define _const_port__all_outputs 0b00000000

#define _const_adc__in0 (u8)(0b11111110)
#define _const_adc__in1 (u8)(0b11111101)
#define _const_adc__in2 (u8)(0b11111011)
#define _const_adc__in3 (u8)(0b11110111)
#define _const_adc__in4 (u8)(0b11101111)
#define _const_adc__in5 (u8)(0b11011111)
#define _const_adc__in6 (u8)(0b10111111)
#define _const_adc__in7 (u8)(0b01111111)
#define _const_adc__all_analogs (u8)(0b00000000)
#define _const_adc__all_digitals (u8)(0b11111111)
#define _const_adc__bits_8 0
#define _const_adc__bits_10 1
#define _const_adc__ch0 0
#define _const_adc__ch1 1
#define _const_adc__ch2 2
#define _const_adc__ch3 3
#define _const_adc__ch4 4
#define _const_adc__ch5 5
#define _const_adc__ch6 6
#define _const_adc__ch7 7

inline u16  adc__read(u8 channel) {
	ADCON0_CHS = channel; 
	GO_DONE = 1; 
	while( GO_DONE == 1 ) { 
	} 
	return (u16)((ADRESH << 8) | ADRESL); 
}

inline u8  adc__read_byte(u8 channel) {
	ADCON0_CHS = channel; 
	GO_DONE = 1; 
	while( GO_DONE == 1 ) { 
	} 
	return (u8)(ADRESH); 
}

#define adc__setup(pins, nbits) \
ANSEL = (u8)(~pins); \
TRISA &= 0b11101000; \
TRISA |= ~(pins | 0b11111000); \
TRISA |= ~((pins | 0b11110111) << 1); \
TRISC &= 0b11110000; \
TRISC |= ~((pins | 0b00001111) >> 4); \
if( _const_main__cpu_freq_mhz >= 12 ) { \
	ADCON1 = 0b01100000;  \
} \
else if( _const_main__cpu_freq_mhz >= 6 ) { \
	ADCON1 = 0b00100000;  \
} \
else if( _const_main__cpu_freq_mhz >= 3 ) { \
	ADCON1 = 0b01010000;  \
} \
else if( _const_main__cpu_freq_mhz >= 2 ) { \
	ADCON1 = 0b00010000;  \
} \
else if( _const_main__cpu_freq_mhz >= 1 ) { \
	ADCON1 = 0b01000000;  \
} \
else { \
	ADCON1 = 0b00000000;  \
} \
ADFM = nbits; \
ADON = 1; 

#define time__sleep(ts) __delay_ms(ts << 10)

#define time__sleep_ms(tms) __delay_ms(tms)

#define time__sleep_us(tus) __delay_us(tus)

#define port__b_pullups(enable) RBPU = (i32)(!enable)

#define port__read(name)  (u8)(*(&PORTA + id))

#define port__setup(name, mode) *(&TRISA + id) = mode

#define port__write(name, value) *(&PORTA + id) = value

void main(void) {
	adc__setup(_const_adc__in2, _const_adc__bits_8); 
	port__setup(_const_port__c, _const_port__all_outputs); 
	port__setup(_const_port__a, 0b11111100); 
	while( true ) {
		u8 value = (u8)(adc__read_byte(_const_adc__ch2)); 
		port__write(_const_port__c, (u8)(value & 0b00111111)); 
		port__write(_const_port__a, (u8)((value & 0b11000000) >> 6)); 
		time__sleep_ms(1); 
	} 
}

