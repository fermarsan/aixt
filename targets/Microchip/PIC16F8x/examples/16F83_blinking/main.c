// This C code was automatically generated by Aixt Compiler
//     https://github.com/fermarsan/aixt
// Device = PIC16F83
// Board = ---
// Backend = c

#include <xc.h>
#include <stdint.h>
#include <stdbool.h>
typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
// typedef NOT SUPPORTED i64;
typedef int8_t isize;
typedef int32_t int_literal;
typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
// typedef NOT SUPPORTED u64;
typedef uint8_t usize;
typedef float f32;
// typedef NOT SUPPORTED f64;
typedef float float_literal;
typedef char rune;

#define _const_main__cpu_freq_mhz	_const_main__cpu_freq/1000000
#define _const_main__cpu_freq  10000000

#define _XTAL_FREQ _const_main__cpu_freq

#pragma config FOSC = HS        // Oscillator Selection bits (HS oscillator)
#pragma config WDTE = OFF       // Watchdog Timer (WDT disabled)
#pragma config PWRTE = ON       // Power-up Timer Enable bit (Power-up Timer is disabled)
#pragma config CP = OFF         // Code Protection bit (Code protection disabled)

#if defined(TIMER0_IRQ_IN_USE) || defined(EXT_IRQ_IN_USE)   // if any interrupt source is activated

// #ifdef EXT_IRQ_IN_USE    
// void (*ptr_ext_isr)(void);      // Interrupt Service Routine pointer
// #endif  // EXT_IRQ_IN_USE 

// #ifdef TIMER0_IRQ_IN_USE    
// void (*ptr_timer0_isr)(void);   // Interrupt Service Routine pointer
// #endif  // TIMER0_IRQ_IN_USE 

void __interrupt() Global_ISR() {
	#ifdef EXT_IRQ_IN_USE    
	if(INTF == 1) {
		ptr_ext_isr();
		INTF = 0;
	}
	#endif  // EXT_IRQ_IN_USE 
	
	#ifdef TIMER0_IRQ_IN_USE    
	if(T0IF == 1) {
		ptr_timer0_isr();
		T0IF = 0;
	}
	#endif  // TIMER0_IRQ_IN_USE 
}

#endif  // defined(TIMER0_IRQ_IN_USE) || defined(EXT_IRQ_IN_USE)

#define _const_pin__a0 0
#define _const_pin__a1 1
#define _const_pin__a2 2
#define _const_pin__a3 3
#define _const_pin__a4 4
#define _const_pin__b0 8
#define _const_pin__b1 9
#define _const_pin__b2 10
#define _const_pin__b3 11
#define _const_pin__b4 12
#define _const_pin__b5 13
#define _const_pin__b6 14
#define _const_pin__b7 15
#define _const_pin__irq 8
#define _const_pin__output 0
#define _const_pin__input 1
#define _const_pin__port_a A
#define _const_pin__port_b B

#define time__sleep(ts) __delay_ms(ts << 10)

#define time__sleep_ms(tms) __delay_ms(tms)

#define time__sleep_us(tus) __delay_us(tus)

#define pin__high(id) *(&PORTA + (id / 8)) |= 0x01 << (id % 8)

#define pin__low(id) *(&PORTA + (id / 8)) &= ~(0x01 << (id % 8))

#define pin__read(id)  ((u8) (u8)((*(&PORTA + (id / 8)) >> (id % 8)) & 0x01))

#define pin__setup(id, mode) \
if( mode == 1 ) { \
	*(&TRISA + (id / 8)) |= (0x01 << (id % 8));  \
} \
else { \
	*(&TRISA + (id / 8)) &= ~(0x01 << (id % 8));  \
}; 

#define pin__toggle(id) *(&PORTA + (id / 8)) ^= 0x01 << (id % 8)

#define pin__write(id, value) \
*(&PORTA + (id >> 3)) &= (~(0x01 << (id % 8))); \
*(&PORTA + (id >> 3)) |= (value << (id % 8)); 

void main(void) {
	pin__setup(_const_pin__b4, _const_pin__output); 
	while( true ) {
		pin__toggle(_const_pin__b4); 
		time__sleep_ms(250); 
	} 
}

